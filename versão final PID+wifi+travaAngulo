#include <Kalman.h>
#include "Wire.h"
#include "MPU6050.h"
#include <HTTP_Method.h>
#include <Uri.h>
#include <WebServer.h>
#include <Wire.h>
#include <WiFi.h>
#include <ESP32Servo.h>

Servo motorPitch;
Servo motorRoll;

bool debug = 0;
bool printServos = 1;

MPU6050 mpu;         // Creates an MPU6050 object
Kalman kalmanPitch;  // Kalman filter object for pitch
Kalman kalmanRoll;   // Kalman filter object for roll

const char* ssid = "CLARO_2G81DDF4";
const char* password = "7281DDF4";

WebServer server(80);

int16_t acelX, acelY, acelZ;
int16_t giroX, giroY, giroZ;

// PID constants
float Kp = 2.0;
float Ki = 0.06;
float Kd = 0.0;

float setPointPitch = 0.0;
float setPointRoll = 0.0;

// Variables for storing pitch and roll before PID
float pitch, roll;

// PID variables
float pitchError, pitchPreviousError;
float pitchIntegral, pitchDerivative;
float pitchOutput;

float rollError, rollPreviousError;
float rollIntegral, rollDerivative;
float rollOutput;

float rollPosInicial = 95.0;
float pitchPosInicial = 90.0;

unsigned long timer = micros();

void setup() {
  Wire.begin();  // Initialize I2C
  Serial.begin(115200);
  mpu.initialize();  // Initialize MPU6050

  // Initialize Kalman filter
  kalmanPitch.setAngle(0);
  kalmanRoll.setAngle(0);

  // Adjust Kalman filter parameters to prioritize accelerometer data
  kalmanPitch.setQangle(0.001); // Process noise covariance for accelerometer
  kalmanPitch.setQbias(0.003);  // Process noise covariance for gyroscope bias
  kalmanPitch.setRmeasure(0.02); // Measurement noise covariance, increase to rely more on accelerometer

  kalmanRoll.setQangle(0.001);
  kalmanRoll.setQbias(0.003);
  kalmanRoll.setRmeasure(0.02);

  motorPitch.attach(15);
  motorRoll.attach(4);

  motorPitch.write(pitchPosInicial);
  motorRoll.write(rollPosInicial);

  timer = micros();

  // WiFi connection
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("connecting to WIFI ...");
  }

  Serial.println("conectado");

  // Define the "/data" route to send sensor data
  server.on("/data", HTTP_GET, []() {
    String json = "{\"pitch\":" + String(pitch) + ", \"roll\":" + String(roll) + ", \"pidPitchOutput\":" + String(pitchOutput) + ", \"pidRollOutput\":" + String(rollOutput) + "}";
    server.send(200, "application/json", json);
  });

  // Start server
  server.begin();
  Serial.println("server started");
  Serial.println("Access: http://");
  Serial.println(WiFi.localIP());
}

void loop() {
  // Read MPU6050 data
  mpu.getMotion6(&acelX, &acelY, &acelZ, &giroX, &giroY, &giroZ);

  // Convert accelerometer data to physical units (2g range)
  float acelX_g = acelX / 16384.0;
  float acelY_g = acelY / 16384.0;
  float acelZ_g = acelZ / 16384.0;

  // Convert gyroscope data to physical units (±250°/s range)
  float giroX_deg_s = giroX / 131.0;
  float giroY_deg_s = giroY / 131.0;
  float giroZ_deg_s = giroZ / 131.0;

  // Calculate time difference
  float dt = (micros() - timer) / 1000000.0;
  timer = micros();

  // Calculate angles based on accelerometer data
  float pitchAcel = atan2(acelY, acelZ) * 180 / PI;
  float rollAcel = atan2(acelX, acelZ) * 180 / PI;

  // Pass data through Kalman filter for more accurate angles
  pitch = kalmanPitch.getAngle(pitchAcel, giroY_deg_s, dt);
  roll = kalmanRoll.getAngle(rollAcel, giroX_deg_s, dt);

  // PID control for pitch
  pitchError = setPointPitch - pitch;
  pitchIntegral += pitchError * dt;
  pitchDerivative = (pitchError - pitchPreviousError) / dt;
  pitchOutput = Kp * pitchError + Ki * pitchIntegral + Kd * pitchDerivative;
  pitchPreviousError = pitchError;

  // PID control for roll
  rollError = setPointRoll - roll;
  rollIntegral += rollError * dt;
  rollDerivative = (rollError - rollPreviousError) / dt;
  rollOutput = Kp * rollError + Ki * rollIntegral + Kd * rollDerivative;
  rollPreviousError = rollError;

  if (debug) {
    Serial.print("  pitch:  ");
    Serial.print(pitch);
    Serial.print("  pitchOutput: ");
    Serial.print(pitchOutput);

    Serial.print("  roll:  ");
    Serial.print(roll);
    Serial.print("  rollOutput:  ");
    Serial.println(rollOutput);
  }

  motorPitch.write(-pitchOutput + pitchPosInicial);
  motorRoll.write(-rollOutput + rollPosInicial);

  if(printServos){
    Serial.print("anguloMotorPitch:  ");
    Serial.print(-pitchOutput + pitchPosInicial);
    Serial.print("  anguloMotorRoll:  ");
    Serial.println(-rollOutput + rollPosInicial);
  }

  server.handleClient();
}
